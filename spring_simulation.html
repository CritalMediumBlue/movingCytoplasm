<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f0f0f0;
        }
        canvas {
            display: block;
        }
        .container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
    
    </style>
</head>
<body>
    <div class="container">
        <div id="simulation-canvas"></div>
    </div>

    <!-- Include Matter.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    
    <script>
        // Module aliases for Matter.js
        const Engine = Matter.Engine,
              Render = Matter.Render,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Body = Matter.Body,
              Composite = Matter.Composite,
              Constraint = Matter.Constraint,
              Events = Matter.Events,
              Common = Matter.Common;

        // Create engine
        const engine = Engine.create();
        engine.world.gravity.y = 0;

        // Create renderer
        const render = Render.create({
            element: document.getElementById('simulation-canvas'),
            engine: engine,
            options: {
                width: 1500,
                height: 1100,
                wireframes: false,
                background: '#f0f0f0'
            }
        });

        // Configuration
        const config = {
            numCouples: 50,
            numCentroids: 3,
            canvasWidth: 1500,
            canvasHeight: 1100,
            equilibriumLength: 20,
            particleRadius: 2,
            colors: {
                active: {
                    fill: '#4285F4',
                    stroke: '#2A56C6'
                },
                inactive: {
                    fill: '#EA4335',
                    stroke: '#B31412'
                },
                spring: '#34A853'
            },
            physics: {
                restitution: 0.8,
                friction: 0.005,
                stiffness: 0.005,
                damping: 0,
                forceMultiplier: 0.00005
            }
        };

        // Calculate stretch threshold
        const stretchThreshold = config.equilibriumLength * 2;

        // Create walls to keep particles within bounds
        const walls = [
            Bodies.rectangle(0, config.canvasHeight/2, 56.3, config.canvasHeight, { 
                isStatic: true,
                render: { fillStyle: '#333333' }
            }),     // left
            Bodies.rectangle(config.canvasWidth, config.canvasHeight/2, 56.3, config.canvasHeight, { 
                isStatic: true,
                render: { fillStyle: '#333333' }
            }),   // right
            Bodies.rectangle(config.canvasWidth/2, 0, config.canvasWidth, 56.3, { 
                isStatic: true,
                render: { fillStyle: '#333333' }
            }),     // top
            Bodies.rectangle(config.canvasWidth/2, config.canvasHeight, config.canvasWidth, 56.3, { 
                isStatic: true,
                render: { fillStyle: '#333333' }
            })    // bottom
        ];

        // Create maze walls and obstacles - simplified version
        const mazeElements = [];
        
 
  

        
        // Add just a few interesting static objects
        
        // Circular obstacles - reduced number
        const circles = [
            { x: 400, y: 400, radius: 150 },
            { x: 1100, y: 400, radius: 100 },
            { x: 750, y: 550, radius: 150 },
            { x: 1000, y: 800, radius: 150 },
            { x: 200, y: 800, radius: 150 },
            { x: 500, y: 200, radius: 100 },
            { x: 900, y: 200, radius: 100 },
            { x: 200, y: 600, radius: 100 },
            { x: 1100, y: 600, radius: 100 },
            { x: 750, y: 900, radius: 100 }
        ];
        
        circles.forEach(circle => {
            mazeElements.push(
                Bodies.circle(circle.x, circle.y, circle.radius, {
                    isStatic: true,
                    render: { 
                        fillStyle: '#8BC34A',
                        strokeStyle: '#689F38',
                        lineWidth: 2
                    }
                })
            );
        });
        
   
        
  
        
        // Add all maze elements to the world
        Composite.add(engine.world, [...walls, ...mazeElements]);

        // Couple class to manage a pair of particles and their spring
        class Couple {
            constructor(id, x, y) {
                this.id = id;
                
                // Create particles
                this.particleA = this.createParticle(
                    x, 
                    y, 
                    true, // static
                    config.colors.inactive
                );
                
                this.particleB = this.createParticle(
                    x + config.equilibriumLength, 
                    y, 
                    false, // not static
                    config.colors.active
                );
                
                // Create spring constraint between particles
                this.spring = Constraint.create({
                    bodyA: this.particleA,
                    bodyB: this.particleB,
                    stiffness: config.physics.stiffness,
                    damping: config.physics.damping,
                    length: config.equilibriumLength,
                    render: {
                        type: 'line',
                        anchors: false, 
                        strokeStyle: config.colors.spring,
                        lineWidth: 0.123
                    }
                });
                
                // Track which particle is currently active
                this.activeParticle = this.particleB;
                this.inactiveParticle = this.particleA;
                
                // Add to world
                Composite.add(engine.world, [this.particleA, this.particleB, this.spring]);
            }
            
            createParticle(x, y, isStatic, colorSet) {
                return Bodies.circle(x, y, config.particleRadius, {
                    isStatic: isStatic,
                    restitution: config.physics.restitution,
                    friction: config.physics.friction,
                    render: {
                        fillStyle: colorSet.fill,
                        strokeStyle: colorSet.stroke,
                        lineWidth: 0.123
                    },
                    coupleId: this.id // Store reference to the couple
                });
            }
            
            // Calculate current spring length
            getCurrentLength() {
                return this.calculateDistance(
                    this.particleA.position, 
                    this.particleB.position
                );
            }
            
            // Calculate distance between two points
            calculateDistance(pointA, pointB) {
                const dx = pointB.x - pointA.x;
                const dy = pointB.y - pointA.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            // Apply random motion to a particle with directional bias from centroid
            applyRandomMotion() {
                const force = config.physics.forceMultiplier;
                
                // Get random components
                let forceX = (Math.random() - 0.5) * force;
                let forceY = (Math.random() - 0.5) * force;

               

                
            // Apply bias based on both centroids' directions
            // Bias strength (0.5 means 50% random, 50% biased toward direction)
            const biasStrength = 0.3;
            
            // Calculate combined influence from both centroids
            let combinedDirectionX = 0;
            let combinedDirectionY = 0;
            
            // Weight the influence of each centroid based on distance
            let totalWeight = 0;
            
            for (let i = 0; i < centroids.length; i++) {
                const distance = this.calculateDistance(
                    this.activeParticle.position,
                    centroids[i].position
                );
                
                // Inverse distance weighting - closer centroids have more influence
                const weight = 1 / Math.max(distance, 0.1); // Avoid division by zero
                totalWeight += weight;
                
                // Add weighted contribution from this centroid
                combinedDirectionX += centroids[i].direction.x * weight;
                combinedDirectionY += centroids[i].direction.y * weight;
            }
            
            // Normalize the combined direction
            if (totalWeight > 0) {
                combinedDirectionX /= totalWeight;
                combinedDirectionY /= totalWeight;
                
                // Normalize to unit vector
                const magnitude = Math.sqrt(combinedDirectionX * combinedDirectionX + combinedDirectionY * combinedDirectionY);
                if (magnitude > 0) {
                    combinedDirectionX /= magnitude;
                    combinedDirectionY /= magnitude;
                }
            }
            
            // Add bias component
            forceX = forceX * (1 - biasStrength) + combinedDirectionX * force * biasStrength;
            forceY = forceY * (1 - biasStrength) + combinedDirectionY * force * biasStrength;
                
                Body.applyForce(
                    this.activeParticle, 
                    this.activeParticle.position, 
                    { x: forceX, y: forceY }
                );
            }
            
            // Swap active and inactive particles
            swapActiveParticle() {
                // Swap active and inactive particles
                [this.activeParticle, this.inactiveParticle] = 
                    [this.inactiveParticle, this.activeParticle];
                
                // Update physics properties
                Body.setStatic(this.activeParticle, false);
                Body.setStatic(this.inactiveParticle, true);
                
                // Update colors
                this.activeParticle.render.fillStyle = config.colors.active.fill;
                this.activeParticle.render.strokeStyle = config.colors.active.stroke;
                this.inactiveParticle.render.fillStyle = config.colors.inactive.fill;
                this.inactiveParticle.render.strokeStyle = config.colors.inactive.stroke;
            }
            
            // Update the couple's state
            update() {
                // Check if spring is stretched beyond threshold
                const currentLength = this.getCurrentLength();
                if (currentLength > stretchThreshold) {
                    this.swapActiveParticle();
                }
                
                // Apply random motion to the active particle
                this.applyRandomMotion();
            }
        }
        
        // Create array to store all couples
        const couples = [];
        
        // Function to bind two couples with a spring
        function bindToCentroid(particle, centroid, options = {}) {
            // Default options
            const springOptions = {
                equilibriumLength: options.equilibriumLength || config.equilibriumLength * 2,
                stiffness: config.physics.stiffness *0.1*Math.random(),
                damping: options.damping || config.physics.damping,
                color: options.color || '#9C27B0', // Purple color for inter-couple springs
                lineWidth: 0.123
            };

            
            const springToCentroid = Constraint.create({
                bodyA: particle,
                bodyB: centroid,    
                stiffness: springOptions.stiffness,
                damping: springOptions.damping,
                length: springOptions.equilibriumLength,
                render: {
                    type: 'line',
                    anchors: false,
                    strokeStyle: springOptions.color,
                    lineWidth: springOptions.lineWidth
                }
            });
            
            // Add the spring to the world
            Composite.add(engine.world, springToCentroid);
            
            // Return the spring for potential future reference
            return springToCentroid;
        }
        
        // Create couples with distributed positions
        function createCouples() {
            // Start all couples in a clear area near the top left
            const startX = 100;
            const startY = 100;
            const spreadFactor = 50;
            
            for (let i = 0; i < config.numCouples; i++) {
                // Create a more clustered starting position
                const x = startX + Math.random() * spreadFactor;
                const y = startY + Math.random() * spreadFactor;
                
                // Create couple and add to array
                couples.push(new Couple(i, x, y));
            }
        }
        // Create an array to store centroids
        const centroids = [];

        for (let i = 0; i < config.numCentroids; i++) {
            // Create a centroid - a central point that all particles will be connected to
            const centroid = Bodies.circle(
                100 + (i * 50), // Position centroids in the starting area
                100 + (i * 50),
                3, // slightly larger radius for visibility
                {
                    isStatic: false,
                    render: {
                        fillStyle: '#FF9800', // Different colors for each centroid
                        strokeStyle:'#E65100'
                    },
                    // Add direction as a unit vector property
                    direction: { 
                        x: i === 0 ? 1 : (i === 1 ? 0 : -0.5), // Different initial directions
                        y: i === 0 ? 0 : (i === 1 ? 1 : 0.5)
                    }
                }
            );
            
            // Add centroid to the world and to our array
            Composite.add(engine.world, centroid);
            centroids.push(centroid);
        }
        // Create all couples
        createCouples();
        
        // Bind all particles in each couple to both centroids
        for (let i = 0; i < config.numCouples; i++) {
            // Connect to both centroids
            for (let j = 0; j < centroids.length; j++) {
                const centroid = centroids[j];
                
                // Bind the active particle to the centroid
                bindToCentroid(couples[i].activeParticle, centroid, {
                    equilibriumLength: config.equilibriumLength * 1.5,
                    stiffness: config.physics.stiffness * 0.1*Math.random(),
                    color: j === 0 ? '#673AB7' : '#FF9800'
                });
                
                // Also bind the inactive particle to the centroid
                bindToCentroid(couples[i].inactiveParticle, centroid, {
                    equilibriumLength: config.equilibriumLength * 1.5,
                    stiffness: config.physics.stiffness * 0.1*Math.random(),
                    color: j === 0 ? '#673AB7' : '#FF9800'
                });
                
            }
        }
        
        // Run the renderer and engine
        Render.run(render);
        Runner.run(Runner.create(), engine);
        
        // Function to update centroid directions independently
        function updateCentroidDirections() {
            // Update each centroid's direction independently
            centroids.forEach(centroid => {
                // Change direction gradually
                // Create a small random change in direction
                const angleChange = (Math.random() - 0.5) * 0.1; // Small random angle change
                
                // Get current direction
                const currentX = centroid.direction.x;
                const currentY = centroid.direction.y;
                
                // Calculate current angle
                let angle = Math.atan2(currentY, currentX);
                
                // Apply change
                angle += angleChange;
                
                // Update direction (keeping it as a unit vector)
                centroid.direction.x = Math.cos(angle);
                centroid.direction.y = Math.sin(angle);
          
            
         
            });
        }
        
        // Add event listener for before update
        Events.on(engine, 'beforeUpdate', () => {
            // Update all couples
            couples.forEach(couple => couple.update());
            
            // Update centroid directions
            updateCentroidDirections();
        });
        
        // Add some text instructions
        Render.lookAt(render, {
            min: { x: 0, y: 0 },
            max: { x: config.canvasWidth, y: config.canvasHeight }
        });
    
    </script>
</body>
</html>
